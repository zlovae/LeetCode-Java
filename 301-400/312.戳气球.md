有 `n `个气球，编号为`0` 到 `n-1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。

现在要求你戳破所有的气球。每当你戳破一个气球 `i` 时，你可以获得 `nums[left] * nums[i] * nums[right]` 个硬币。 这里的 `left` 和 `right` 代表和 `i` 相邻的两个气球的序号。注意当你戳破了气球 `i` 后，气球 `left` 和气球 `right` 就变成了相邻的气球。

求所能获得硬币的最大数量。

说明:

你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100
示例:
```
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```
这个问题需要注意的一点就是隔着的元素是不影响的，所以要记录位置i和j之间的元素一起戳破的情况
```
class Solution {
    public int maxCoins(int[] nums) {
        int length = nums.length+2;
        //dp[i][j]表示戳破从i+1到j-1能得到的最大收益；上三角矩阵
        int[][] dp = new int[length][length];
        int[] num = new int[length];
        for(int i=1; i<length-1; i++) {
            num[i]=nums[i-1];
        }
        num[0]=1; num[length-1]=1;
        
        for(int step=2; step<length; step++) {
            for(int i=0; i<length-step; i++) {
                int j=i+step;
                for(int k=i+1; k<j; k++) {
                    dp[i][j]=Math.max(dp[i][j], num[i]*num[k]*num[j]+dp[i][k]+dp[k][j]);
                }
            }
        }
        
        return dp[0][length-1];
    }
}
```